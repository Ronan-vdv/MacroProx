use super::game;
use super::net_common;
use crate::game::GameReadiness;
use crate::net_common::Commands;
use crate::net_common::NetColour;
use crate::net_common::NetPosition;
use crate::net_common::RegistrationInfo;
use message_io::network::Endpoint;
use message_io::network::{NetEvent, Transport};
use message_io::node::NodeEvent;
use message_io::node::{self};
use std::f32::NAN;
use std::net::IpAddr;
use std::net::Ipv4Addr;
use std::str::FromStr;
use std::sync::{Arc, Mutex};
use std::time::Duration;

enum Signal {
    TrySendUpdate,
}

pub fn run_client(settings: net_common::ClientSettings, state_lock: Arc<Mutex<game::GameState>>) {
    let ares = Ipv4Addr::from_str(&settings.ip);

    let a: Ipv4Addr;
    match ares {
        Err(err) => {
            net_common::set_error(&state_lock, err.to_string());
            return;
        }
        Ok(res) => a = res,
    }

    let address = std::net::SocketAddr::new(IpAddr::V4(a), settings.port);

    let (handler, listener) = node::split::<Signal>();
    let con_res = handler.network().connect(Transport::FramedTcp, address);

    let server: Endpoint;

    match con_res {
        Ok((end, _)) => server = end,
        Err(err) => {
            net_common::set_error(&state_lock, err.to_string());
            return;
        }
    }

    let mut pos = NetPosition { x: NAN, y: NAN };

    listener.for_each(move |event| match event {
        NodeEvent::Network(net_event) => match net_event {
            NetEvent::Connected(_endpoint, _ok) => {
                println!("Endpoint: {}", _endpoint);
                if !_ok {
                    net_common::set_error(&state_lock, String::from("Could not connect"));
                    return;
                }

                println!("Connected! Requesting registration....");
                let tosend = bincode::serialize(&Commands::RegisterPlayer(RegistrationInfo{colour: NetColour::from_col(settings.colour), name: settings.name.clone()})).unwrap();
                let _status = handler.network().send(_endpoint, &tosend);   
            }
            NetEvent::Accepted(_, _) => unreachable!(), // Only generated by listening
            NetEvent::Message(_endpoint, data) => {
                let res = bincode::deserialize(&data);

                match res {
                    Ok(dat) => {
                        let mut state = state_lock.lock().unwrap();
                        match dat {
                            Commands::Move(_) => (), //Not for client
                            Commands::RegisterPlayer(_) => (), //Not for client
                            Commands::SendMap(map) => {
                                for b in map.buildings {
                                    state.buildings.push(b);
                                }
                            }
                            Commands::SendPlayerInfo(player_info) => {
                                for i in player_info.players {
                                    state.players.insert(i.id, i);
                                }
                            }
                            Commands::AllowClientReady(id) => {
                                //Server has sent everything, ready to start
                                state.own_player = id;
                                state.ready = GameReadiness::Ready;

                                //Start network update loop
                                handler.signals().send_with_timer(Signal::TrySendUpdate, Duration::from_millis(100));
                            }
                            Commands::MovedPlayers(dat) => {

                                // println!("Got data?");
                                match state.ready { //Only try and update if ready
                                    GameReadiness::Error(_) => (),
                                    GameReadiness::Loading => (),
                                    GameReadiness::Ready => {
                                        //Set updated positions
                                        for val in dat {                                         
                                            //Don't update self from server info
                                            if val.id != state.own_player {
                                                match state.players.get_mut(&val.id) {
                                                    None => {
                                                        println!("Warning! Server tried to update non-existent player {}", val.id);
                                                    },
                                                    Some(p) => {
                                                        p.position = val.pos;
                                                    }
                                                }
                                            }
                                            
                                        }
                                    }
                                }
                            },
                            Commands::AddPlayer(player) => {
                                state.players.insert(player.id, player);
                            },
                            Commands::RemovePlayer(id) => {
                                let t = state.players.get(&id);
                                match t {
                                    None => {
                                        println!("Warning! Server tried to remove non-existent player");
                                    },
                                    Some(d) => {
                                        println!("{} left the game", d.name);
                                        state.players.remove(&id);
                                    }
                                }
                            },
                        }

                        drop(state);
                    }
                    Err(err) => {
                        println!("{}", err);
                    }
                }

                // println!("Received from server: {}", String::from_utf8_lossy(data));
            }
            NetEvent::Disconnected(_endpoint) => {
                let mut game = state_lock.lock().unwrap();
                game.ready = GameReadiness::Error(String::from("Got Disconnected"));
                println!("Disconnected");
                drop(game);
            }
        },
        NodeEvent::Signal(signal) => match signal {
            Signal::TrySendUpdate => {
                let state = state_lock.lock().unwrap();
                let p = state.players.get(&state.own_player).unwrap();
                let p_pos = p.position;
                drop(state);

                //Check if client position has changed
                //Right now the only part of client state
                if !p_pos.equals(&pos) {
                    pos = p_pos;
                    let tosend = bincode::serialize(&Commands::Move(p_pos))
                    .unwrap();

                    let _status = handler.network().send(server, &tosend);
                }

                //Re-schedule data send
                handler
                    .signals()
                    .send_with_timer(Signal::TrySendUpdate, Duration::from_millis(10));

            }
        },
    });
}
